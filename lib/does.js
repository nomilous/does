// Generated by CoffeeScript 1.6.3
var deferred, lastInstance;

deferred = require('also').deferred;

lastInstance = void 0;

module.exports = function(config) {
  var api, local, mode, seq;
  if (config == null) {
    config = {};
  }
  mode = config.mode || 'spec';
  seq = 0;
  if (mode === 'spec') {
    lastInstance = local = {
      expectations: {},
      /*
      
      
      `local.expectations` - Houses currently active expectations 
      -----------------------------------------------------------
      
      Storage Structure
      
      ```
      
      expectations/:uuid:/createdAt   # * Timestamp
      expectations/:uuid:/timeout     # * ((hopefully)) Timeout of the parent mocha test.
      expectations/:uuid:/object      # * Reference to object
      expectations/:uuid:/type        # * Constructor name (if present) ##undecided
      expectations/:uuid:/functions   # * List of function expectations
      
      expectations/:uuid:/functions/fnName/original       # * Container for the original function
      expectations/:uuid:/functions/fnName/original/fn    # * Reference to the original function
      
      expectations/:uuid:/functions/fnName/expects    # * Array of mock function containers
      ```
      
      * Currently only the first mock in the array is used
      * Later it should switch to the second upon calling the first to allow more than 
        one mock to be set up in a sequece
      
      ```
      expectations/:uuid:/functions/fnName/expects/0/called     # * Boolean - was it called
      expectations/:uuid:/functions/fnName/expects/0/count      # * (temporary) - count of calls
      expectations/:uuid:/functions/fnName/expects/0/break      # * (later) - sets a breakpoint - COMPLEXITY: test timeout
      expectations/:uuid:/functions/fnName/expects/0/stub       # * The stub function (wrapper)
      expectations/:uuid:/functions/fnName/expects/0/spy        # * Boolean - should it call onward to origal function 
      expectations/:uuid:/functions/fnName/expects/0/fn         # * The function mocker
      
      ```
      
      * The stub function (wrapper) substitutes the real function on the ""live"" object 
      * It calls the mocker as assigned by `object.does fnName: -> 'this fn is the mocker'`
      * It then calls the original if spy is true
      
      expectations/:uuid:/properties  # later
      */

      spectate: deferred(function(action, object) {
        if (object == null) {
          return action.reject(new Error("does can't expect undefined to do stuff"));
        }
        return (function(uuid) {
          local.expectations[uuid] = {
            createdAt: new Date,
            object: object,
            type: (function() {
              try {
                return object.constructor.name;
              } catch (_error) {}
            })(),
            functions: {}
          };
          object.does = function(expectations) {
            var fn, fnName, spy, _results;
            _results = [];
            for (fnName in expectations) {
              if (fnName.match(/^_/)) {
                fnName = fnName.slice(1);
                spy = true;
                fn = expectations["_" + fnName];
              } else {
                spy = false;
                fn = expectations[fnName];
              }
              _results.push(local.expectFn({
                uuid: uuid,
                fnName: fnName,
                spy: spy,
                fn: fn
              }));
            }
            return _results;
          };
          Object.defineProperty(object.does, 'uuid', {
            get: function() {
              return uuid;
            }
          });
          return action.resolve(object);
        })(++seq);
      }),
      expectFn: function(_arg) {
        var expects, fn, fnName, functions, object, original, spy, stub, type, uuid, _ref, _ref1;
        uuid = _arg.uuid, fnName = _arg.fnName, fn = _arg.fn, spy = _arg.spy;
        _ref = local.expectations[uuid], object = _ref.object, type = _ref.type, functions = _ref.functions;
        _ref1 = functions[fnName] || (functions[fnName] = {
          expects: [],
          original: {
            fn: object[fnName]
          }
        }), expects = _ref1.expects, original = _ref1.original;
        if (expects[0] != null) {
          console.log("um? (##undecided: multiple expectations on function) - already expecting " + type + "." + fnName);
          return;
        }
        if (spy) {
          object[fnName] = stub = function() {
            /* STUB (spy)*/

            expects[0].called = true;
            return expects[0].count++;
          };
        } else {
          object[fnName] = stub = function() {
            /* STUB (mocker)*/

            expects[0].called = true;
            return expects[0].count++;
          };
        }
        return expects[0] = {
          called: false,
          count: 0,
          stub: stub,
          spy: spy,
          fn: fn
        };
      },
      verify: function() {}
    };
  } else {
    throw new Error("does doesn't " + mode);
  }
  return api = {
    spectate: local.spectate,
    verify: local.verify
  };
};

Object.defineProperty(module.exports, '_test', {
  get: function() {
    return function() {
      return lastInstance;
    };
  }
});
