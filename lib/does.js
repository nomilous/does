// Generated by CoffeeScript 1.6.3
var deferred, detect, getUuid, lastInstance, should;

deferred = require('also').deferred;

should = require('should');

lastInstance = void 0;

module.exports = function(config) {
  var local, mode, rootContext, routes, seq;
  if (config == null) {
    config = {};
  }
  mode = ((function() {
    try {
      return config.does.mode;
    } catch (_error) {}
  })()) || 'spec';
  seq = 0;
  rootContext = this;
  if (mode === 'spec') {
    lastInstance = local = {
      spectacles: {},
      /*
      
      
      `local.spectacles` - Houses currently active spectacles
      -------------------------------------------------------
      
      Storage Structure
      
      ```
      
      spectacles/:uuid:/createdAt   # * Timestamp
      spectacles/:uuid:/timeout     # * ((hopefully)) Timeout of the parent mocha test.
      spectacles/:uuid:/object      # * Reference to object
      spectacles/:uuid:/type        # * Constructor name (if present) ##undecided
      spectacles/:uuid:/tagged      # * Is a special case spectacle
      spectacles/:uuid:/functions   # * List of function expectations
      spectacles/:uuid:/spectator   # * Spectator function name (does or $does)
      
      spectacles/:uuid:/functions/fnName/original       # * Container for the original function
      spectacles/:uuid:/functions/fnName/original/fn    # * Reference to the original function
      
      spectacles/:uuid:/functions/fnName/expects    # * Array of mock function containers
      ```
      
      * Currently only the first mock in the array is used
      * Later it should switch to the second upon calling the first to allow more than 
        one mock to be set up in a sequece
      
      ```
      spectacles/:uuid:/functions/fnName/expects/0/called     # * Boolean - was it called
      spectacles/:uuid:/functions/fnName/expects/0/count      # * (temporary) - count of calls
      spectacles/:uuid:/functions/fnName/expects/0/break      # * (later) - sets a breakpoint - COMPLEXITIES: test timeouts, runs respawn new process
      spectacles/:uuid:/functions/fnName/expects/0/stub       # * The stub function (wrapper)
      spectacles/:uuid:/functions/fnName/expects/0/spy        # * Boolean - should it call onward to origal function 
      spectacles/:uuid:/functions/fnName/expects/0/fn         # * The function mocker
      
      ```
      
      * The stub function (wrapper) substitutes the real function on the ""live"" object 
      * It calls the mocker as assigned by `object.does fnName: -> 'this fn is the mocker'`
      * It then calls the original if spy is true
      
      spectacles/:uuid:/properties  # later
      */

      tagged: {},
      /*
      
      
      `local.tagged` - Special case (designer) spectacles
      ---------------------------------------------------
      
      * for spectated objcts that span the entire run (not flushed at each it)
      * see also ipso.save() https://github.com/nomilous/ipso/commit/d73f6ec3df301201429a69df4d11fc984d5d75d3
      
      tagged/:tag:/object -> spectacles/:uuid: (where tagged is true)
      */

      get: function(opts, callback) {
        var name;
        try {
          name = opts.query.tag;
        } catch (_error) {}
        if (name == null) {
          return callback(new Error("does.get(opts) requires opts.query.tag"));
        }
        if (local.tagged[name] == null) {
          return callback(new Error("does has nothing with tag " + name));
        }
        return callback(null, local.tagged[name].object);
      },
      runtime: {},
      activate: function(runtime) {
        var original, rname, tapTimeout, _base;
        local.runtime.current = runtime;
        rname = (_base = local.runtime).name || (_base.name = detect(rootContext));
        if (rname !== 'mocha') {
          return;
        }
        if (runtime.spec != null) {
          tapTimeout = function() {
            local.runtime.onTimeout = runtime.spec.timer._onTimeout;
            return runtime.spec.timer._onTimeout = function() {
              return local.assert(runtime.resolver).then(function() {
                return local.runtime.onTimeout.call(runtime.context);
              }, function(exception) {
                console.log({
                  exception: expectation
                });
                return runtime.resolver(exception);
              });
            };
          };
          tapTimeout();
          try {
            original = runtime.context.timeout;
          } catch (_error) {}
          try {
            return runtime.context.timeout = function(ms) {
              original.call(runtime.context, ms);
              return tapTimeout();
            };
          } catch (_error) {}
        }
      },
      spectate: deferred(function(action, opts, object) {
        var name, spectatorName;
        if (object == null) {
          return action.reject(new Error("does can't expect undefined to do stuff"));
        }
        name = opts.name;
        if (opts.tagged && (local.tagged[name] != null)) {
          return action.reject(new Error("does can't reassign tag " + name));
        }
        spectatorName = (object.does != null) && (object.does.uuid == null) ? '$does' : 'does';
        if ((object[spectatorName] != null) && object[spectatorName].active) {
          local.flush();
        }
        return (function(uuid) {
          var spectated;
          local.spectacles[uuid] = spectated = {
            uuid: uuid,
            createdAt: new Date,
            object: object,
            type: (function() {
              try {
                return object.constructor.name;
              } catch (_error) {}
            })(),
            name: name,
            tagged: opts.tagged || false,
            functionsCount: 0,
            functions: {},
            spectator: spectatorName
          };
          if (opts.tagged) {
            local.tagged[name] = {
              object: spectated
            };
          }
          object[spectatorName] = function(expectations) {
            var fn, fnName, spy;
            for (fnName in expectations) {
              if (fnName.match(/^_/)) {
                fnName = fnName.slice(1);
                spy = true;
                fn = expectations["_" + fnName];
              } else {
                spy = false;
                fn = expectations[fnName];
              }
              local.expectFn({
                uuid: uuid,
                fnName: fnName,
                spy: spy,
                fn: fn
              });
            }
            return object;
          };
          Object.defineProperty(object[spectatorName], 'uuid', {
            get: function() {
              return uuid;
            }
          });
          return action.resolve(object);
        })(++seq);
      }),
      spectateSync: function(opts, object) {
        var name, spectatorName;
        if (object == null) {
          throw new Error("does can't expect undefined to do stuff");
        }
        name = opts.name;
        if (opts.tagged && (local.tagged[name] != null)) {
          throw new Error("does can't reassign tag " + name);
        }
        spectatorName = (object.does != null) && (object.does.uuid == null) ? '$does' : 'does';
        return (function(uuid) {
          var spectated;
          local.spectacles[uuid] = spectated = {
            uuid: uuid,
            createdAt: new Date,
            object: object,
            type: (function() {
              try {
                return object.constructor.name;
              } catch (_error) {}
            })(),
            name: name,
            tagged: opts.tagged || false,
            functionsCount: 0,
            functions: {},
            spectator: spectatorName
          };
          if (opts.tagged) {
            local.tagged[name] = {
              object: spectated
            };
          }
          object[spectatorName] = function(expectations) {
            var fn, fnName, spy;
            for (fnName in expectations) {
              if (fnName.match(/^_/)) {
                fnName = fnName.slice(1);
                spy = true;
                fn = expectations["_" + fnName];
              } else {
                spy = false;
                fn = expectations[fnName];
              }
              local.expectFn({
                uuid: uuid,
                fnName: fnName,
                spy: spy,
                fn: fn
              });
            }
            return object;
          };
          Object.defineProperty(object[spectatorName], 'uuid', {
            get: function() {
              return uuid;
            }
          });
          return object;
        })(++seq);
      },
      expectFn: function(_arg) {
        var expect, expectation, expects, fn, fnName, functions, object, original, spectator, spy, stub, tagged, type, uuid, _ref;
        uuid = _arg.uuid, fnName = _arg.fnName, fn = _arg.fn, spy = _arg.spy;
        expectation = local.spectacles[uuid];
        object = expectation.object, type = expectation.type, tagged = expectation.tagged, spectator = expectation.spectator, functions = expectation.functions;
        _ref = functions[fnName] || (functions[fnName] = {
          expects: [],
          original: {
            fn: object[fnName]
          }
        }), expects = _ref.expects, original = _ref.original;
        expectation.functionsCount++;
        object[spectator].active = true;
        if (expects[0] != null) {
          console.log("does doesn't currently support multiple expectations - already spectating " + type + "." + fnName + "()");
          return;
        }
        if (spy) {
          object[fnName] = stub = function() {
            /* STUB (spy)*/

            expect.called = true;
            expect.count++;
            expect.fn.apply(this, arguments);
            if (original.fn != null) {
              return original.fn.apply(this, arguments);
            }
          };
        } else {
          object[fnName] = stub = function() {
            /* STUB (mocker)*/

            expect.called = true;
            expect.count++;
            return expect.fn.apply(this, arguments);
          };
        }
        return expects[0] = expect = {
          called: false,
          count: 0,
          stub: stub,
          spy: spy,
          fn: fn
        };
      },
      flush: deferred(function(action) {
        var expectation, expects, fnName, functions, object, original, tagged, uuid;
        console.log("TODO: flush removes all spectations not created by an ancestor suite's hooks");
        for (uuid in local.spectacles) {
          expectation = local.spectacles[uuid];
          object = expectation.object, functions = expectation.functions, tagged = expectation.tagged;
          for (fnName in functions) {
            if (tagged) {
              expects = functions[fnName].expects;
              expects[0].called = false;
              expects[0].count = 0;
              continue;
            }
            original = functions[fnName].original;
            object[fnName] = original.fn;
            delete functions[fnName];
          }
          if (tagged) {
            continue;
          }
          delete local.spectacles[uuid];
        }
        return action.resolve();
      }),
      assert: deferred(function(action, done) {
        var call, error, expect, expected, expects, fnName, functions, functionsCount, name, object, original, resulted, spectator, type, uuid, _ref, _ref1;
        if (done == null) {
          done = null;
        }
        if (typeof done === 'function') {
          expected = {};
          resulted = {};
          for (uuid in local.spectacles) {
            _ref = local.spectacles[uuid], object = _ref.object, type = _ref.type, name = _ref.name, spectator = _ref.spectator, functionsCount = _ref.functionsCount, functions = _ref.functions;
            if (!(functionsCount > 0)) {
              continue;
            }
            expected[name] = {
              functions: {}
            };
            resulted[name] = {
              functions: {}
            };
            for (fnName in functions) {
              _ref1 = functions[fnName], expects = _ref1.expects, original = _ref1.original;
              expect = expects[0];
              call = "" + type + "." + fnName + "()";
              expected[name].functions[call] = 'was called';
              if (expect.called) {
                resulted[name].functions[call] = 'was called';
              } else {
                resulted[name].functions[call] = 'was NOT called';
              }
            }
            object[spectator].active = false;
          }
          try {
            resulted.should.eql(expected);
          } catch (_error) {
            error = _error;
            done(error);
            action.reject(error);
          }
        }
        return local.flush().then(function() {
          return action.resolve();
        });
      })
    };
  } else {
    throw new Error("does doesn't " + mode);
  }
  routes = {
    spectate: local.spectate,
    spectateSync: local.spectateSync,
    assert: local.assert,
    get: local.get,
    activate: local.activate
  };
  routes.get.$api = {};
  return routes;
};

detect = function(context) {
  if ((context.xit != null) && (context.xdescribe != null) && (context.xcontext != null)) {
    return 'mocha';
  }
};

getUuid = function(object) {
  var error, uuid;
  try {
    return uuid = object.does.uuid;
  } catch (_error) {
    error = _error;
    try {
      return uuid = object.$does.uuid;
    } catch (_error) {}
  }
};

Object.defineProperty(module.exports, '_test', {
  enumerable: true,
  get: function() {
    var fn;
    fn = function() {
      return lastInstance;
    };
    fn.README = "\nThis `does._test()` exposes the entire internal structure of the \nmost recently created instance of a does spectation object.\n\nIt is intended for does' own internal testing.\n\nBE ADVISED! The structures may change drastically!\n\nOnce the design stabalizes a more formal interface for integration will be provided.\n\nThoughts, ideas and requests are welcome.\n";
    return fn;
  }
});
