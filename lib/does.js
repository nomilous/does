// Generated by CoffeeScript 1.6.3
var colors, deferred, detect, getUuid, lastInstance, should;

deferred = require('also').deferred;

should = require('should');

colors = require('colors');

lastInstance = void 0;

module.exports = function(config) {
  var local, mode, rootContext, routes, seq;
  if (config == null) {
    config = {};
  }
  mode = ((function() {
    try {
      return config.does.mode;
    } catch (_error) {}
  })()) || 'spec';
  seq = 0;
  rootContext = this;
  if (mode === 'spec') {
    lastInstance = local = {
      spectacles: {},
      /*
      
      
      `local.spectacles` - Houses currently active spectacles
      -------------------------------------------------------
      
      Storage Structure
      
      ```
      
      spectacles/:uuid:/createdAt   # * Timestamp
      spectacles/:uuid:/timeout     # * ((hopefully)) Timeout of the parent mocha test.
      spectacles/:uuid:/object      # * Reference to object
      spectacles/:uuid:/type        # * Constructor name (if present) ##undecided
      spectacles/:uuid:/tagged      # * Is a special case spectacle
      spectacles/:uuid:/functions   # * List of function expectations
      spectacles/:uuid:/spectator   # * Spectator function name (does or $does)
      
      spectacles/:uuid:/functions/fnName/original       # * Container for the original function
      spectacles/:uuid:/functions/fnName/original/fn    # * Reference to the original function
      
      spectacles/:uuid:/functions/fnName/expects    # * Array of mock function containers
      ```
      
      * Currently only the first mock in the array is used
      * Later it should switch to the second upon calling the first to allow more than 
        one mock to be set up in a sequece
      
      ```
      spectacles/:uuid:/functions/fnName/expects/0/called     # * Boolean - was it called
      spectacles/:uuid:/functions/fnName/expects/0/count      # * (temporary) - count of calls
      spectacles/:uuid:/functions/fnName/expects/0/break      # * (later) - sets a breakpoint - COMPLEXITIES: test timeouts, runs respawn new process
      spectacles/:uuid:/functions/fnName/expects/0/stub       # * The stub function (wrapper)
      spectacles/:uuid:/functions/fnName/expects/0/spy        # * Boolean - should it call onward to origal function 
      spectacles/:uuid:/functions/fnName/expects/0/fn         # * The function mocker
      
      ```
      
      * The stub function (wrapper) substitutes the real function on the ""live"" object 
      * It calls the mocker as assigned by `object.does fnName: -> 'this fn is the mocker'`
      * It then calls the original if spy is true
      
      spectacles/:uuid:/properties  # later
      */

      tagged: {},
      /*
      
      
      `local.tagged` - Special case (designer) spectacles
      ---------------------------------------------------
      
      * for spectated objcts that span the entire run (not flushed at each it)
      * see also ipso.save() https://github.com/nomilous/ipso/commit/d73f6ec3df301201429a69df4d11fc984d5d75d3
      
      tagged/:tag:/object -> spectacles/:uuid: (where tagged is true)
      */

      get: function(opts, callback) {
        var name;
        try {
          name = opts.query.tag;
        } catch (_error) {}
        if (name == null) {
          return callback(new Error("does.get(opts) requires opts.query.tag"));
        }
        if (local.tagged[name] == null) {
          return callback(new Error("does has nothing with tag " + name));
        }
        return callback(null, local.tagged[name].object);
      },
      runtime: {
        active: false
      },
      activate: function(runtime) {
        var ancestors, original, parent, rname, tapTimeout, _base, _base1, _results;
        local.runtime.current = runtime;
        rname = (_base = local.runtime).name || (_base.name = detect(rootContext));
        if (rname !== 'mocha') {
          return;
        }
        if (runtime.spec != null) {
          tapTimeout = function() {
            local.runtime.onTimeout = runtime.spec.timer._onTimeout;
            return runtime.spec.timer._onTimeout = function() {
              return local.assert(runtime.resolver).then(function() {
                return local.runtime.onTimeout.call(runtime.context);
              }, function(exception) {});
            };
          };
          tapTimeout();
          try {
            original = runtime.context.timeout;
          } catch (_error) {}
          try {
            runtime.context.timeout = function(ms) {
              original.call(runtime.context, ms);
              return tapTimeout();
            };
          } catch (_error) {}
        }
        if (((function() {
          try {
            return runtime.spec.type === 'test';
          } catch (_error) {}
        })())) {
          local.runtime.active = true;
          ancestors = (_base1 = local.runtime).ancestors || (_base1.ancestors = []);
          ancestors.length = 0;
          parent = runtime.spec.parent;
          _results = [];
          while (parent != null) {
            ancestors.unshift(parent);
            _results.push(parent = parent.parent);
          }
          return _results;
        } else if (((function() {
          try {
            return runtime.spec.type === 'hook';
          } catch (_error) {}
        })())) {
          return local.runtime.active = true;
        } else {
          return local.runtime.active = false;
        }
      },
      spectate: deferred(function(action, opts, object) {
        var existing, name, spectatorName, uuid;
        if (object == null) {
          return action.reject(new Error("does can't expect undefined to do stuff"));
        }
        name = opts.name;
        if (opts.tagged && (local.tagged[name] != null)) {
          return action.reject(new Error("does can't reassign tag " + name));
        }
        spectatorName = (object.does != null) && (object.does.uuid == null) ? '$does' : 'does';
        if (uuid = getUuid(object)) {
          if (existing = local.spectacles[uuid]) {
            if (existing.name !== name) {
              return action.reject(new Error("does cannot rename '" + existing.name + "' to '" + name + "'"));
            }
            if (opts.tagged) {
              existing.tagged = true;
              local.tagged[name] = {
                object: existing
              };
            }
            console.log({
              EXISTING: uuid
            });
            return action.resolve(object);
          }
        }
        return (function(uuid) {
          var spectated;
          console.log({
            NEW: uuid
          });
          local.spectacles[uuid] = spectated = {
            uuid: uuid,
            createdAt: new Date,
            object: object,
            type: (function() {
              try {
                return object.constructor.name;
              } catch (_error) {}
            })(),
            name: name,
            tagged: opts.tagged || false,
            functionsCount: 0,
            functions: {},
            spectator: spectatorName
          };
          if (opts.tagged) {
            local.tagged[name] = {
              object: spectated
            };
          }
          object[spectatorName] = function(expectations) {
            return local.does(uuid, object, expectations);
          };
          Object.defineProperty(object[spectatorName], 'uuid', {
            get: function() {
              return uuid;
            }
          });
          return action.resolve(object);
        })(++seq);
      }),
      spectateSync: function(opts, object) {
        var name, spectatorName;
        if (object == null) {
          throw new Error("does can't expect undefined to do stuff");
        }
        name = opts.name;
        if (opts.tagged && (local.tagged[name] != null)) {
          throw new Error("does can't reassign tag " + name);
        }
        spectatorName = (object.does != null) && (object.does.uuid == null) ? '$does' : 'does';
        return (function(uuid) {
          var spectated;
          local.spectacles[uuid] = spectated = {
            uuid: uuid,
            createdAt: new Date,
            object: object,
            type: (function() {
              try {
                return object.constructor.name;
              } catch (_error) {}
            })(),
            name: name,
            tagged: opts.tagged || false,
            functionsCount: 0,
            functions: {},
            spectator: spectatorName
          };
          if (opts.tagged) {
            local.tagged[name] = {
              object: spectated
            };
          }
          object[spectatorName] = function(expectations) {
            return local.does(uuid, object, expectations);
          };
          Object.defineProperty(object[spectatorName], 'uuid', {
            get: function() {
              return uuid;
            }
          });
          return object;
        })(++seq);
      },
      does: function(uuid, object, expectations) {
        var creator, fn, fnName, spy;
        if (!local.runtime.active) {
          console.log('does:', 'warning: ignored expectation declaration outside of ipso enabled hook or test scope'.yellow);
          return object;
        }
        creator = local.runtime.current.spec;
        for (fnName in expectations) {
          if (fnName.match(/^_/)) {
            fnName = fnName.slice(1);
            spy = true;
            fn = expectations["_" + fnName];
          } else {
            spy = false;
            fn = expectations[fnName];
          }
          local.expectFn({
            creator: creator,
            uuid: uuid,
            fnName: fnName,
            spy: spy,
            fn: fn
          });
        }
        return object;
      },
      reset: deferred(function(action) {
        var ancestors;
        ancestors = local.runtime.ancestors;
        return action.resolve();
      }),
      expectFn: function(_arg) {
        var creator, expect, expectation, expects, fn, fnName, functions, object, original, spectator, spy, stub, tagged, type, uuid, _ref;
        creator = _arg.creator, uuid = _arg.uuid, fnName = _arg.fnName, fn = _arg.fn, spy = _arg.spy;
        expectation = local.spectacles[uuid];
        object = expectation.object, type = expectation.type, tagged = expectation.tagged, spectator = expectation.spectator, functions = expectation.functions;
        _ref = functions[fnName] || (functions[fnName] = {
          expects: [],
          original: {
            fn: object[fnName]
          }
        }), expects = _ref.expects, original = _ref.original;
        expectation.functionsCount++;
        if (expects[0] != null) {
          console.log("does doesn't currently support multiple expectations - already spectating " + type + "." + fnName + "()");
          return;
        }
        if (spy) {
          object[fnName] = stub = function() {
            /* STUB (spy)*/

            expect.called = true;
            expect.count++;
            expect.fn.apply(this, arguments);
            if (original.fn != null) {
              return original.fn.apply(this, arguments);
            }
          };
        } else {
          object[fnName] = stub = function() {
            /* STUB (mocker)*/

            expect.called = true;
            expect.count++;
            return expect.fn.apply(this, arguments);
          };
        }
        return expects[0] = expect = {
          creator: creator,
          called: false,
          count: 0,
          stub: stub,
          spy: spy,
          fn: fn
        };
      },
      assert: deferred(function(action, done) {
        var call, error, expect, expected, expects, fnName, functions, functionsCount, name, object, original, resulted, spec, spectator, type, uuid, _ref, _ref1;
        if (done == null) {
          done = null;
        }
        spec = local.runtime.current.spec;
        if (spec.type !== 'test') {
          return action.resolve();
        }
        if (typeof done === 'function') {
          expected = {};
          resulted = {};
          for (uuid in local.spectacles) {
            _ref = local.spectacles[uuid], object = _ref.object, type = _ref.type, name = _ref.name, spectator = _ref.spectator, functionsCount = _ref.functionsCount, functions = _ref.functions;
            if (!(functionsCount > 0)) {
              continue;
            }
            expected[name] = {
              functions: {}
            };
            resulted[name] = {
              functions: {}
            };
            for (fnName in functions) {
              _ref1 = functions[fnName], expects = _ref1.expects, original = _ref1.original;
              expect = expects[0];
              call = "" + type + "." + fnName + "()";
              expected[name].functions[call] = 'was called';
              if (expect.called) {
                resulted[name].functions[call] = 'was called';
              } else {
                resulted[name].functions[call] = 'was NOT called';
              }
            }
          }
          try {
            resulted.should.eql(expected);
          } catch (_error) {
            error = _error;
            done(error);
            action.reject(error);
          }
        }
        return local.reset().then(function() {
          return action.resolve();
        });
      })
    };
  } else {
    throw new Error("does doesn't " + mode);
  }
  routes = {
    spectate: local.spectate,
    spectateSync: local.spectateSync,
    assert: local.assert,
    get: local.get,
    activate: local.activate
  };
  routes.get.$api = {};
  return routes;
};

detect = function(context) {
  if ((context.xit != null) && (context.xdescribe != null) && (context.xcontext != null)) {
    return 'mocha';
  }
};

getUuid = function(object) {
  var error, uuid;
  try {
    return uuid = object.does.uuid;
  } catch (_error) {
    error = _error;
    try {
      return uuid = object.$does.uuid;
    } catch (_error) {}
  }
};

Object.defineProperty(module.exports, '_test', {
  enumerable: true,
  get: function() {
    var fn;
    fn = function() {
      return lastInstance;
    };
    fn.README = "\nThis `does._test()` exposes the entire internal structure of the \nmost recently created instance of a does spectation object.\n\nIt is intended for does' own internal testing.\n\nBE ADVISED! The structures may change drastically!\n\nOnce the design stabalizes a more formal interface for integration will be provided.\n\nThoughts, ideas and requests are welcome.\n";
    return fn;
  }
});
