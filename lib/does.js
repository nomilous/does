// Generated by CoffeeScript 1.6.3
var deferred, lastInstance;

deferred = require('also').deferred;

lastInstance = void 0;

module.exports = function(config) {
  var api, local, mode, seq;
  if (config == null) {
    config = {};
  }
  mode = config.mode || 'spec';
  seq = 0;
  if (mode === 'spec') {
    lastInstance = local = {
      expectations: {},
      /*
      
      
      `local.expectations` - Houses currently active expectations 
      -----------------------------------------------------------
      
      Storage Structure
      
      ```
      expectations/:uuid:/object      # * Reference to object
      expectations/:uuid:/name        # * Constructor name (if present)
      expectations/:uuid:/functions   # * List of function expectations
      
      expectations/:uuid:/functions/fnName/original   # * Reference to the original function
      expectations/:uuid:/functions/fnName/expects    # * Array of mock function containers
      ```
      
      * Currently only the first mock in the array is used
      * Later it should switch to the second upon calling the first to allow more than 
        one mock to be set up in a sequece
      
      ```
      expectations/:uuid:/functions/fnName/expects/0/called     # * Boolean - was it called
      expectations/:uuid:/functions/fnName/expects/0/pass       # * Boolean - should it call onward to origal function 
      expectations/:uuid:/functions/fnName/expects/0/fn         # * The function mocker
      expectations/:uuid:/functions/fnName/expects/0/stub       # * The stub function (wrapper)
      ```
      
      * The stub function (wrapper) substitutes the real function on the ""live"" object 
      * It calls the mocker as assigned by `object.does fnName: -> 'this fn is the mocker'`
      * It then calls the original if pass is true
      */

      spectate: deferred(function(action, object) {
        if (object == null) {
          return action.reject(new Error("does can't expect undefined to do stuff"));
        }
        return (function(id) {
          local.expectations[id] = {
            name: (function() {
              try {
                return object.constructor.name;
              } catch (_error) {}
            })(),
            object: object,
            functions: {}
          };
          object.does = function(expectations) {
            var fn, fnName, spy, _results;
            _results = [];
            for (fnName in expectations) {
              if (fnName.match(/^_/)) {
                fnName = fnName.slice(1);
                spy = true;
                fn = expectations["_" + title];
              } else {
                spy = false;
                fn = expectations[fnName];
              }
              _results.push(local.expectFn({
                fnName: fnName,
                uuid: id,
                spy: spy,
                fn: fn
              }));
            }
            return _results;
          };
          Object.defineProperty(object.does, 'uuid', {
            get: function() {
              return id;
            }
          });
          return action.resolve(object);
        })(++seq);
      }),
      expectFn: function(_arg) {
        var fn, fnName, spy, uuid;
        uuid = _arg.uuid, fnName = _arg.fnName, fn = _arg.fn, spy = _arg.spy;
      },
      verify: function() {}
    };
  } else {
    throw new Error("does doesn't " + mode);
  }
  return api = {
    spectate: local.spectate,
    verify: local.verify
  };
};

Object.defineProperty(module.exports, '_test', {
  get: function() {
    return function() {
      return lastInstance;
    };
  }
});
